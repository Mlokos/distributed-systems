//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.4
//
// <auto-generated>
//
// Generated from file `Domotics.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Domotics_h__
#define __Domotics_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 4
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Domotics
{

class Heater;
class HeaterPrx;
class StaticCamera;
class StaticCameraPrx;
class DynamicCamera;
class DynamicCameraPrx;
class Lamp;
class LampPrx;
class RGBLamp;
class RGBLampPrx;

}

namespace Domotics
{

struct colorRGB
{
    int red;
    int green;
    int blue;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(red, green, blue);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Domotics
{

class Heater : public virtual ::Ice::Object
{
public:

    using ProxyType = HeaterPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual int getTemperature(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getTemperature(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setTemperature(int temperature, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setTemperature(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class StaticCamera : public virtual ::Ice::Object
{
public:

    using ProxyType = StaticCameraPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual int getZoom(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getZoom(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setZoom(int zoom, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setZoom(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool isRecording(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_isRecording(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setRecording(bool record, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setRecording(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class DynamicCamera : public virtual StaticCamera
{
public:

    using ProxyType = DynamicCameraPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual int getAngle(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAngle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setAngle(int angle, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setAngle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Lamp : public virtual ::Ice::Object
{
public:

    using ProxyType = LampPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual int getBrightness(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getBrightness(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setBrightness(int brightness, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setBrightness(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class RGBLamp : public virtual Lamp
{
public:

    using ProxyType = RGBLampPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual colorRGB getColor(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getColor(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setColor(colorRGB color, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setColor(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Domotics
{

class HeaterPrx : public virtual ::Ice::Proxy<HeaterPrx, ::Ice::ObjectPrx>
{
public:

    int getTemperature(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &HeaterPrx::_iceI_getTemperature, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getTemperatureAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &HeaterPrx::_iceI_getTemperature, context);
    }

    ::std::function<void()>
    getTemperatureAsync(::std::function<void(int)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::HeaterPrx::_iceI_getTemperature, context);
    }

    /// \cond INTERNAL
    void _iceI_getTemperature(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    void setTemperature(int temperature, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &HeaterPrx::_iceI_setTemperature, temperature, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setTemperatureAsync(int temperature, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &HeaterPrx::_iceI_setTemperature, temperature, context);
    }

    ::std::function<void()>
    setTemperatureAsync(int temperature,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::HeaterPrx::_iceI_setTemperature, temperature, context);
    }

    /// \cond INTERNAL
    void _iceI_setTemperature(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    HeaterPrx() = default;
    friend ::std::shared_ptr<HeaterPrx> IceInternal::createProxy<HeaterPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class StaticCameraPrx : public virtual ::Ice::Proxy<StaticCameraPrx, ::Ice::ObjectPrx>
{
public:

    int getZoom(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &StaticCameraPrx::_iceI_getZoom, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getZoomAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &StaticCameraPrx::_iceI_getZoom, context);
    }

    ::std::function<void()>
    getZoomAsync(::std::function<void(int)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::StaticCameraPrx::_iceI_getZoom, context);
    }

    /// \cond INTERNAL
    void _iceI_getZoom(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    void setZoom(int zoom, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StaticCameraPrx::_iceI_setZoom, zoom, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setZoomAsync(int zoom, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StaticCameraPrx::_iceI_setZoom, zoom, context);
    }

    ::std::function<void()>
    setZoomAsync(int zoom,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::StaticCameraPrx::_iceI_setZoom, zoom, context);
    }

    /// \cond INTERNAL
    void _iceI_setZoom(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    bool isRecording(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &StaticCameraPrx::_iceI_isRecording, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto isRecordingAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &StaticCameraPrx::_iceI_isRecording, context);
    }

    ::std::function<void()>
    isRecordingAsync(::std::function<void(bool)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::StaticCameraPrx::_iceI_isRecording, context);
    }

    /// \cond INTERNAL
    void _iceI_isRecording(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    void setRecording(bool record, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StaticCameraPrx::_iceI_setRecording, record, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setRecordingAsync(bool record, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StaticCameraPrx::_iceI_setRecording, record, context);
    }

    ::std::function<void()>
    setRecordingAsync(bool record,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::StaticCameraPrx::_iceI_setRecording, record, context);
    }

    /// \cond INTERNAL
    void _iceI_setRecording(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, bool, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    StaticCameraPrx() = default;
    friend ::std::shared_ptr<StaticCameraPrx> IceInternal::createProxy<StaticCameraPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class DynamicCameraPrx : public virtual ::Ice::Proxy<DynamicCameraPrx, StaticCameraPrx>
{
public:

    int getAngle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &DynamicCameraPrx::_iceI_getAngle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getAngleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &DynamicCameraPrx::_iceI_getAngle, context);
    }

    ::std::function<void()>
    getAngleAsync(::std::function<void(int)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::DynamicCameraPrx::_iceI_getAngle, context);
    }

    /// \cond INTERNAL
    void _iceI_getAngle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    void setAngle(int angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &DynamicCameraPrx::_iceI_setAngle, angle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setAngleAsync(int angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &DynamicCameraPrx::_iceI_setAngle, angle, context);
    }

    ::std::function<void()>
    setAngleAsync(int angle,
                  ::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::DynamicCameraPrx::_iceI_setAngle, angle, context);
    }

    /// \cond INTERNAL
    void _iceI_setAngle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    DynamicCameraPrx() = default;
    friend ::std::shared_ptr<DynamicCameraPrx> IceInternal::createProxy<DynamicCameraPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class LampPrx : public virtual ::Ice::Proxy<LampPrx, ::Ice::ObjectPrx>
{
public:

    int getBrightness(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &LampPrx::_iceI_getBrightness, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getBrightnessAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &LampPrx::_iceI_getBrightness, context);
    }

    ::std::function<void()>
    getBrightnessAsync(::std::function<void(int)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::LampPrx::_iceI_getBrightness, context);
    }

    /// \cond INTERNAL
    void _iceI_getBrightness(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    void setBrightness(int brightness, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LampPrx::_iceI_setBrightness, brightness, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setBrightnessAsync(int brightness, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LampPrx::_iceI_setBrightness, brightness, context);
    }

    ::std::function<void()>
    setBrightnessAsync(int brightness,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::LampPrx::_iceI_setBrightness, brightness, context);
    }

    /// \cond INTERNAL
    void _iceI_setBrightness(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    LampPrx() = default;
    friend ::std::shared_ptr<LampPrx> IceInternal::createProxy<LampPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class RGBLampPrx : public virtual ::Ice::Proxy<RGBLampPrx, LampPrx>
{
public:

    colorRGB getColor(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Domotics::colorRGB>(true, this, &RGBLampPrx::_iceI_getColor, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getColorAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Domotics::colorRGB>>().get_future())
    {
        return _makePromiseOutgoing<::Domotics::colorRGB, P>(false, this, &RGBLampPrx::_iceI_getColor, context);
    }

    ::std::function<void()>
    getColorAsync(::std::function<void(::Domotics::colorRGB)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Domotics::colorRGB>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::RGBLampPrx::_iceI_getColor, context);
    }

    /// \cond INTERNAL
    void _iceI_getColor(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Domotics::colorRGB>>&, const ::Ice::Context&);
    /// \endcond

    void setColor(const colorRGB& color, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RGBLampPrx::_iceI_setColor, color, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setColorAsync(const colorRGB& color, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RGBLampPrx::_iceI_setColor, color, context);
    }

    ::std::function<void()>
    setColorAsync(const colorRGB& color,
                  ::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Domotics::RGBLampPrx::_iceI_setColor, color, context);
    }

    /// \cond INTERNAL
    void _iceI_setColor(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const colorRGB&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    RGBLampPrx() = default;
    friend ::std::shared_ptr<RGBLampPrx> IceInternal::createProxy<RGBLampPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Domotics::colorRGB>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Domotics::colorRGB, S>
{
    static void read(S* istr, ::Domotics::colorRGB& v)
    {
        istr->readAll(v.red, v.green, v.blue);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Domotics
{

using HeaterPtr = ::std::shared_ptr<Heater>;
using HeaterPrxPtr = ::std::shared_ptr<HeaterPrx>;

using StaticCameraPtr = ::std::shared_ptr<StaticCamera>;
using StaticCameraPrxPtr = ::std::shared_ptr<StaticCameraPrx>;

using DynamicCameraPtr = ::std::shared_ptr<DynamicCamera>;
using DynamicCameraPrxPtr = ::std::shared_ptr<DynamicCameraPrx>;

using LampPtr = ::std::shared_ptr<Lamp>;
using LampPrxPtr = ::std::shared_ptr<LampPrx>;

using RGBLampPtr = ::std::shared_ptr<RGBLamp>;
using RGBLampPrxPtr = ::std::shared_ptr<RGBLampPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Domotics
{

class Heater;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Heater>&);
::IceProxy::Ice::Object* upCast(Heater*);
/// \endcond

class StaticCamera;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< StaticCamera>&);
::IceProxy::Ice::Object* upCast(StaticCamera*);
/// \endcond

class DynamicCamera;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< DynamicCamera>&);
::IceProxy::Ice::Object* upCast(DynamicCamera*);
/// \endcond

class Lamp;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Lamp>&);
::IceProxy::Ice::Object* upCast(Lamp*);
/// \endcond

class RGBLamp;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< RGBLamp>&);
::IceProxy::Ice::Object* upCast(RGBLamp*);
/// \endcond

}

}

namespace Domotics
{

class Heater;
/// \cond INTERNAL
::Ice::Object* upCast(Heater*);
/// \endcond
typedef ::IceInternal::Handle< Heater> HeaterPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Domotics::Heater> HeaterPrx;
typedef HeaterPrx HeaterPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(HeaterPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class StaticCamera;
/// \cond INTERNAL
::Ice::Object* upCast(StaticCamera*);
/// \endcond
typedef ::IceInternal::Handle< StaticCamera> StaticCameraPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Domotics::StaticCamera> StaticCameraPrx;
typedef StaticCameraPrx StaticCameraPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(StaticCameraPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class DynamicCamera;
/// \cond INTERNAL
::Ice::Object* upCast(DynamicCamera*);
/// \endcond
typedef ::IceInternal::Handle< DynamicCamera> DynamicCameraPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Domotics::DynamicCamera> DynamicCameraPrx;
typedef DynamicCameraPrx DynamicCameraPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(DynamicCameraPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Lamp;
/// \cond INTERNAL
::Ice::Object* upCast(Lamp*);
/// \endcond
typedef ::IceInternal::Handle< Lamp> LampPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Domotics::Lamp> LampPrx;
typedef LampPrx LampPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LampPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class RGBLamp;
/// \cond INTERNAL
::Ice::Object* upCast(RGBLamp*);
/// \endcond
typedef ::IceInternal::Handle< RGBLamp> RGBLampPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Domotics::RGBLamp> RGBLampPrx;
typedef RGBLampPrx RGBLampPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(RGBLampPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Domotics
{

struct colorRGB
{
    ::Ice::Int red;
    ::Ice::Int green;
    ::Ice::Int blue;

    bool operator==(const colorRGB& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(red != rhs_.red)
        {
            return false;
        }
        if(green != rhs_.green)
        {
            return false;
        }
        if(blue != rhs_.blue)
        {
            return false;
        }
        return true;
    }

    bool operator<(const colorRGB& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(red < rhs_.red)
        {
            return true;
        }
        else if(rhs_.red < red)
        {
            return false;
        }
        if(green < rhs_.green)
        {
            return true;
        }
        else if(rhs_.green < green)
        {
            return false;
        }
        if(blue < rhs_.blue)
        {
            return true;
        }
        else if(rhs_.blue < blue)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const colorRGB& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const colorRGB& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const colorRGB& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const colorRGB& rhs_) const
    {
        return !operator<(rhs_);
    }
};

}

namespace Domotics
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::Heater::begin_getTemperature.
 * Create a wrapper instance by calling ::Domotics::newCallback_Heater_getTemperature.
 */
class Callback_Heater_getTemperature_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Heater_getTemperature_Base> Callback_Heater_getTemperaturePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::Heater::begin_setTemperature.
 * Create a wrapper instance by calling ::Domotics::newCallback_Heater_setTemperature.
 */
class Callback_Heater_setTemperature_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Heater_setTemperature_Base> Callback_Heater_setTemperaturePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::StaticCamera::begin_getZoom.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_getZoom.
 */
class Callback_StaticCamera_getZoom_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StaticCamera_getZoom_Base> Callback_StaticCamera_getZoomPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::StaticCamera::begin_setZoom.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_setZoom.
 */
class Callback_StaticCamera_setZoom_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StaticCamera_setZoom_Base> Callback_StaticCamera_setZoomPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::StaticCamera::begin_isRecording.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_isRecording.
 */
class Callback_StaticCamera_isRecording_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StaticCamera_isRecording_Base> Callback_StaticCamera_isRecordingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::StaticCamera::begin_setRecording.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_setRecording.
 */
class Callback_StaticCamera_setRecording_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StaticCamera_setRecording_Base> Callback_StaticCamera_setRecordingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::DynamicCamera::begin_getAngle.
 * Create a wrapper instance by calling ::Domotics::newCallback_DynamicCamera_getAngle.
 */
class Callback_DynamicCamera_getAngle_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DynamicCamera_getAngle_Base> Callback_DynamicCamera_getAnglePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::DynamicCamera::begin_setAngle.
 * Create a wrapper instance by calling ::Domotics::newCallback_DynamicCamera_setAngle.
 */
class Callback_DynamicCamera_setAngle_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DynamicCamera_setAngle_Base> Callback_DynamicCamera_setAnglePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::Lamp::begin_getBrightness.
 * Create a wrapper instance by calling ::Domotics::newCallback_Lamp_getBrightness.
 */
class Callback_Lamp_getBrightness_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Lamp_getBrightness_Base> Callback_Lamp_getBrightnessPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::Lamp::begin_setBrightness.
 * Create a wrapper instance by calling ::Domotics::newCallback_Lamp_setBrightness.
 */
class Callback_Lamp_setBrightness_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Lamp_setBrightness_Base> Callback_Lamp_setBrightnessPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::RGBLamp::begin_getColor.
 * Create a wrapper instance by calling ::Domotics::newCallback_RGBLamp_getColor.
 */
class Callback_RGBLamp_getColor_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RGBLamp_getColor_Base> Callback_RGBLamp_getColorPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Domotics::RGBLamp::begin_setColor.
 * Create a wrapper instance by calling ::Domotics::newCallback_RGBLamp_setColor.
 */
class Callback_RGBLamp_setColor_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RGBLamp_setColor_Base> Callback_RGBLamp_setColorPtr;

}

namespace IceProxy
{

namespace Domotics
{

class Heater : public virtual ::Ice::Proxy<Heater, ::IceProxy::Ice::Object>
{
public:

    ::Ice::Int getTemperature(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getTemperature(_iceI_begin_getTemperature(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getTemperature(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getTemperature(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTemperature(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTemperature(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTemperature(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTemperature(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTemperature(const ::Domotics::Callback_Heater_getTemperaturePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTemperature(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTemperature(const ::Ice::Context& context, const ::Domotics::Callback_Heater_getTemperaturePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTemperature(context, cb, cookie);
    }

    ::Ice::Int end_getTemperature(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getTemperature(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setTemperature(::Ice::Int temperature, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setTemperature(_iceI_begin_setTemperature(temperature, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setTemperature(::Ice::Int temperature, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setTemperature(temperature, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTemperature(::Ice::Int temperature, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTemperature(temperature, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTemperature(::Ice::Int temperature, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTemperature(temperature, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTemperature(::Ice::Int temperature, const ::Domotics::Callback_Heater_setTemperaturePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTemperature(temperature, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTemperature(::Ice::Int temperature, const ::Ice::Context& context, const ::Domotics::Callback_Heater_setTemperaturePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTemperature(temperature, context, cb, cookie);
    }

    void end_setTemperature(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setTemperature(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class StaticCamera : public virtual ::Ice::Proxy<StaticCamera, ::IceProxy::Ice::Object>
{
public:

    ::Ice::Int getZoom(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getZoom(_iceI_begin_getZoom(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getZoom(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getZoom(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getZoom(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getZoom(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getZoom(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getZoom(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getZoom(const ::Domotics::Callback_StaticCamera_getZoomPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getZoom(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getZoom(const ::Ice::Context& context, const ::Domotics::Callback_StaticCamera_getZoomPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getZoom(context, cb, cookie);
    }

    ::Ice::Int end_getZoom(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getZoom(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setZoom(::Ice::Int zoom, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setZoom(_iceI_begin_setZoom(zoom, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setZoom(::Ice::Int zoom, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setZoom(zoom, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setZoom(::Ice::Int zoom, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setZoom(zoom, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setZoom(::Ice::Int zoom, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setZoom(zoom, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setZoom(::Ice::Int zoom, const ::Domotics::Callback_StaticCamera_setZoomPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setZoom(zoom, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setZoom(::Ice::Int zoom, const ::Ice::Context& context, const ::Domotics::Callback_StaticCamera_setZoomPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setZoom(zoom, context, cb, cookie);
    }

    void end_setZoom(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setZoom(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool isRecording(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_isRecording(_iceI_begin_isRecording(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_isRecording(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_isRecording(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isRecording(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isRecording(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isRecording(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isRecording(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isRecording(const ::Domotics::Callback_StaticCamera_isRecordingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isRecording(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isRecording(const ::Ice::Context& context, const ::Domotics::Callback_StaticCamera_isRecordingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isRecording(context, cb, cookie);
    }

    bool end_isRecording(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_isRecording(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setRecording(bool record, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setRecording(_iceI_begin_setRecording(record, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setRecording(bool record, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setRecording(record, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRecording(bool record, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setRecording(record, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setRecording(bool record, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setRecording(record, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setRecording(bool record, const ::Domotics::Callback_StaticCamera_setRecordingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setRecording(record, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setRecording(bool record, const ::Ice::Context& context, const ::Domotics::Callback_StaticCamera_setRecordingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setRecording(record, context, cb, cookie);
    }

    void end_setRecording(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setRecording(bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class DynamicCamera : public virtual ::Ice::Proxy<DynamicCamera, ::IceProxy::Domotics::StaticCamera>
{
public:

    ::Ice::Int getAngle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getAngle(_iceI_begin_getAngle(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getAngle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getAngle(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAngle(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAngle(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAngle(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAngle(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAngle(const ::Domotics::Callback_DynamicCamera_getAnglePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAngle(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAngle(const ::Ice::Context& context, const ::Domotics::Callback_DynamicCamera_getAnglePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAngle(context, cb, cookie);
    }

    ::Ice::Int end_getAngle(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getAngle(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setAngle(::Ice::Int angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setAngle(_iceI_begin_setAngle(angle, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setAngle(::Ice::Int angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setAngle(angle, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAngle(::Ice::Int angle, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setAngle(angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setAngle(::Ice::Int angle, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setAngle(angle, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setAngle(::Ice::Int angle, const ::Domotics::Callback_DynamicCamera_setAnglePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setAngle(angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setAngle(::Ice::Int angle, const ::Ice::Context& context, const ::Domotics::Callback_DynamicCamera_setAnglePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setAngle(angle, context, cb, cookie);
    }

    void end_setAngle(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setAngle(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Lamp : public virtual ::Ice::Proxy<Lamp, ::IceProxy::Ice::Object>
{
public:

    ::Ice::Int getBrightness(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getBrightness(_iceI_begin_getBrightness(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getBrightness(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getBrightness(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBrightness(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBrightness(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBrightness(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBrightness(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBrightness(const ::Domotics::Callback_Lamp_getBrightnessPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBrightness(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBrightness(const ::Ice::Context& context, const ::Domotics::Callback_Lamp_getBrightnessPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBrightness(context, cb, cookie);
    }

    ::Ice::Int end_getBrightness(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getBrightness(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setBrightness(::Ice::Int brightness, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setBrightness(_iceI_begin_setBrightness(brightness, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setBrightness(::Ice::Int brightness, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setBrightness(brightness, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setBrightness(::Ice::Int brightness, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setBrightness(brightness, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setBrightness(::Ice::Int brightness, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setBrightness(brightness, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setBrightness(::Ice::Int brightness, const ::Domotics::Callback_Lamp_setBrightnessPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setBrightness(brightness, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setBrightness(::Ice::Int brightness, const ::Ice::Context& context, const ::Domotics::Callback_Lamp_setBrightnessPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setBrightness(brightness, context, cb, cookie);
    }

    void end_setBrightness(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setBrightness(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class RGBLamp : public virtual ::Ice::Proxy<RGBLamp, ::IceProxy::Domotics::Lamp>
{
public:

    ::Domotics::colorRGB getColor(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getColor(_iceI_begin_getColor(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getColor(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getColor(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getColor(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getColor(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getColor(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getColor(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getColor(const ::Domotics::Callback_RGBLamp_getColorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getColor(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getColor(const ::Ice::Context& context, const ::Domotics::Callback_RGBLamp_getColorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getColor(context, cb, cookie);
    }

    ::Domotics::colorRGB end_getColor(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getColor(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setColor(const ::Domotics::colorRGB& color, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setColor(_iceI_begin_setColor(color, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setColor(const ::Domotics::colorRGB& color, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setColor(color, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setColor(const ::Domotics::colorRGB& color, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setColor(color, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setColor(const ::Domotics::colorRGB& color, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setColor(color, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setColor(const ::Domotics::colorRGB& color, const ::Domotics::Callback_RGBLamp_setColorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setColor(color, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setColor(const ::Domotics::colorRGB& color, const ::Ice::Context& context, const ::Domotics::Callback_RGBLamp_setColorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setColor(color, context, cb, cookie);
    }

    void end_setColor(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setColor(const ::Domotics::colorRGB&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Domotics
{

class Heater : public virtual ::Ice::Object
{
public:

    typedef HeaterPrx ProxyType;
    typedef HeaterPtr PointerType;

    virtual ~Heater();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int getTemperature(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getTemperature(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setTemperature(::Ice::Int temperature, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setTemperature(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Heater& lhs, const Heater& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Heater& lhs, const Heater& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class StaticCamera : public virtual ::Ice::Object
{
public:

    typedef StaticCameraPrx ProxyType;
    typedef StaticCameraPtr PointerType;

    virtual ~StaticCamera();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int getZoom(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getZoom(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setZoom(::Ice::Int zoom, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setZoom(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool isRecording(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_isRecording(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setRecording(bool record, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setRecording(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const StaticCamera& lhs, const StaticCamera& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const StaticCamera& lhs, const StaticCamera& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class DynamicCamera : virtual public StaticCamera
{
public:

    typedef DynamicCameraPrx ProxyType;
    typedef DynamicCameraPtr PointerType;

    virtual ~DynamicCamera();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int getAngle(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getAngle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setAngle(::Ice::Int angle, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setAngle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const DynamicCamera& lhs, const DynamicCamera& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const DynamicCamera& lhs, const DynamicCamera& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Lamp : public virtual ::Ice::Object
{
public:

    typedef LampPrx ProxyType;
    typedef LampPtr PointerType;

    virtual ~Lamp();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int getBrightness(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getBrightness(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setBrightness(::Ice::Int brightness, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setBrightness(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Lamp& lhs, const Lamp& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Lamp& lhs, const Lamp& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class RGBLamp : virtual public Lamp
{
public:

    typedef RGBLampPrx ProxyType;
    typedef RGBLampPtr PointerType;

    virtual ~RGBLamp();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual colorRGB getColor(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getColor(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setColor(const colorRGB& color, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setColor(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const RGBLamp& lhs, const RGBLamp& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const RGBLamp& lhs, const RGBLamp& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Domotics::colorRGB>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Domotics::colorRGB, S>
{
    static void write(S* ostr, const ::Domotics::colorRGB& v)
    {
        ostr->write(v.red);
        ostr->write(v.green);
        ostr->write(v.blue);
    }
};

template<typename S>
struct StreamReader< ::Domotics::colorRGB, S>
{
    static void read(S* istr, ::Domotics::colorRGB& v)
    {
        istr->read(v.red);
        istr->read(v.green);
        istr->read(v.blue);
    }
};

}
/// \endcond

namespace Domotics
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::Heater::begin_getTemperature.
 * Create a wrapper instance by calling ::Domotics::newCallback_Heater_getTemperature.
 */
template<class T>
class CallbackNC_Heater_getTemperature : public Callback_Heater_getTemperature_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Heater_getTemperature(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        HeaterPrx proxy = HeaterPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getTemperature(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_getTemperature.
 */
template<class T> Callback_Heater_getTemperaturePtr
newCallback_Heater_getTemperature(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Heater_getTemperature<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_getTemperature.
 */
template<class T> Callback_Heater_getTemperaturePtr
newCallback_Heater_getTemperature(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Heater_getTemperature<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::Heater::begin_getTemperature.
 * Create a wrapper instance by calling ::Domotics::newCallback_Heater_getTemperature.
 */
template<class T, typename CT>
class Callback_Heater_getTemperature : public Callback_Heater_getTemperature_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Heater_getTemperature(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        HeaterPrx proxy = HeaterPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getTemperature(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_getTemperature.
 */
template<class T, typename CT> Callback_Heater_getTemperaturePtr
newCallback_Heater_getTemperature(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Heater_getTemperature<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_getTemperature.
 */
template<class T, typename CT> Callback_Heater_getTemperaturePtr
newCallback_Heater_getTemperature(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Heater_getTemperature<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::Heater::begin_setTemperature.
 * Create a wrapper instance by calling ::Domotics::newCallback_Heater_setTemperature.
 */
template<class T>
class CallbackNC_Heater_setTemperature : public Callback_Heater_setTemperature_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Heater_setTemperature(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_setTemperature.
 */
template<class T> Callback_Heater_setTemperaturePtr
newCallback_Heater_setTemperature(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Heater_setTemperature<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_setTemperature.
 */
template<class T> Callback_Heater_setTemperaturePtr
newCallback_Heater_setTemperature(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Heater_setTemperature<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_setTemperature.
 */
template<class T> Callback_Heater_setTemperaturePtr
newCallback_Heater_setTemperature(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Heater_setTemperature<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_setTemperature.
 */
template<class T> Callback_Heater_setTemperaturePtr
newCallback_Heater_setTemperature(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Heater_setTemperature<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::Heater::begin_setTemperature.
 * Create a wrapper instance by calling ::Domotics::newCallback_Heater_setTemperature.
 */
template<class T, typename CT>
class Callback_Heater_setTemperature : public Callback_Heater_setTemperature_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Heater_setTemperature(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_setTemperature.
 */
template<class T, typename CT> Callback_Heater_setTemperaturePtr
newCallback_Heater_setTemperature(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Heater_setTemperature<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_setTemperature.
 */
template<class T, typename CT> Callback_Heater_setTemperaturePtr
newCallback_Heater_setTemperature(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Heater_setTemperature<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_setTemperature.
 */
template<class T, typename CT> Callback_Heater_setTemperaturePtr
newCallback_Heater_setTemperature(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Heater_setTemperature<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Heater::begin_setTemperature.
 */
template<class T, typename CT> Callback_Heater_setTemperaturePtr
newCallback_Heater_setTemperature(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Heater_setTemperature<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::StaticCamera::begin_getZoom.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_getZoom.
 */
template<class T>
class CallbackNC_StaticCamera_getZoom : public Callback_StaticCamera_getZoom_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_StaticCamera_getZoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StaticCameraPrx proxy = StaticCameraPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getZoom(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_getZoom.
 */
template<class T> Callback_StaticCamera_getZoomPtr
newCallback_StaticCamera_getZoom(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_getZoom<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_getZoom.
 */
template<class T> Callback_StaticCamera_getZoomPtr
newCallback_StaticCamera_getZoom(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_getZoom<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::StaticCamera::begin_getZoom.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_getZoom.
 */
template<class T, typename CT>
class Callback_StaticCamera_getZoom : public Callback_StaticCamera_getZoom_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_StaticCamera_getZoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StaticCameraPrx proxy = StaticCameraPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getZoom(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_getZoom.
 */
template<class T, typename CT> Callback_StaticCamera_getZoomPtr
newCallback_StaticCamera_getZoom(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_getZoom<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_getZoom.
 */
template<class T, typename CT> Callback_StaticCamera_getZoomPtr
newCallback_StaticCamera_getZoom(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_getZoom<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::StaticCamera::begin_setZoom.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_setZoom.
 */
template<class T>
class CallbackNC_StaticCamera_setZoom : public Callback_StaticCamera_setZoom_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StaticCamera_setZoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setZoom.
 */
template<class T> Callback_StaticCamera_setZoomPtr
newCallback_StaticCamera_setZoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_setZoom<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setZoom.
 */
template<class T> Callback_StaticCamera_setZoomPtr
newCallback_StaticCamera_setZoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_setZoom<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setZoom.
 */
template<class T> Callback_StaticCamera_setZoomPtr
newCallback_StaticCamera_setZoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_setZoom<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setZoom.
 */
template<class T> Callback_StaticCamera_setZoomPtr
newCallback_StaticCamera_setZoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_setZoom<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::StaticCamera::begin_setZoom.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_setZoom.
 */
template<class T, typename CT>
class Callback_StaticCamera_setZoom : public Callback_StaticCamera_setZoom_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StaticCamera_setZoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setZoom.
 */
template<class T, typename CT> Callback_StaticCamera_setZoomPtr
newCallback_StaticCamera_setZoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_setZoom<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setZoom.
 */
template<class T, typename CT> Callback_StaticCamera_setZoomPtr
newCallback_StaticCamera_setZoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_setZoom<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setZoom.
 */
template<class T, typename CT> Callback_StaticCamera_setZoomPtr
newCallback_StaticCamera_setZoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_setZoom<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setZoom.
 */
template<class T, typename CT> Callback_StaticCamera_setZoomPtr
newCallback_StaticCamera_setZoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_setZoom<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::StaticCamera::begin_isRecording.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_isRecording.
 */
template<class T>
class CallbackNC_StaticCamera_isRecording : public Callback_StaticCamera_isRecording_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_StaticCamera_isRecording(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StaticCameraPrx proxy = StaticCameraPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_isRecording(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_isRecording.
 */
template<class T> Callback_StaticCamera_isRecordingPtr
newCallback_StaticCamera_isRecording(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_isRecording<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_isRecording.
 */
template<class T> Callback_StaticCamera_isRecordingPtr
newCallback_StaticCamera_isRecording(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_isRecording<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::StaticCamera::begin_isRecording.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_isRecording.
 */
template<class T, typename CT>
class Callback_StaticCamera_isRecording : public Callback_StaticCamera_isRecording_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_StaticCamera_isRecording(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StaticCameraPrx proxy = StaticCameraPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_isRecording(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_isRecording.
 */
template<class T, typename CT> Callback_StaticCamera_isRecordingPtr
newCallback_StaticCamera_isRecording(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_isRecording<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_isRecording.
 */
template<class T, typename CT> Callback_StaticCamera_isRecordingPtr
newCallback_StaticCamera_isRecording(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_isRecording<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::StaticCamera::begin_setRecording.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_setRecording.
 */
template<class T>
class CallbackNC_StaticCamera_setRecording : public Callback_StaticCamera_setRecording_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StaticCamera_setRecording(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setRecording.
 */
template<class T> Callback_StaticCamera_setRecordingPtr
newCallback_StaticCamera_setRecording(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_setRecording<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setRecording.
 */
template<class T> Callback_StaticCamera_setRecordingPtr
newCallback_StaticCamera_setRecording(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_setRecording<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setRecording.
 */
template<class T> Callback_StaticCamera_setRecordingPtr
newCallback_StaticCamera_setRecording(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_setRecording<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setRecording.
 */
template<class T> Callback_StaticCamera_setRecordingPtr
newCallback_StaticCamera_setRecording(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StaticCamera_setRecording<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::StaticCamera::begin_setRecording.
 * Create a wrapper instance by calling ::Domotics::newCallback_StaticCamera_setRecording.
 */
template<class T, typename CT>
class Callback_StaticCamera_setRecording : public Callback_StaticCamera_setRecording_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StaticCamera_setRecording(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setRecording.
 */
template<class T, typename CT> Callback_StaticCamera_setRecordingPtr
newCallback_StaticCamera_setRecording(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_setRecording<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setRecording.
 */
template<class T, typename CT> Callback_StaticCamera_setRecordingPtr
newCallback_StaticCamera_setRecording(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_setRecording<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setRecording.
 */
template<class T, typename CT> Callback_StaticCamera_setRecordingPtr
newCallback_StaticCamera_setRecording(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_setRecording<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::StaticCamera::begin_setRecording.
 */
template<class T, typename CT> Callback_StaticCamera_setRecordingPtr
newCallback_StaticCamera_setRecording(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StaticCamera_setRecording<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::DynamicCamera::begin_getAngle.
 * Create a wrapper instance by calling ::Domotics::newCallback_DynamicCamera_getAngle.
 */
template<class T>
class CallbackNC_DynamicCamera_getAngle : public Callback_DynamicCamera_getAngle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DynamicCamera_getAngle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DynamicCameraPrx proxy = DynamicCameraPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getAngle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_getAngle.
 */
template<class T> Callback_DynamicCamera_getAnglePtr
newCallback_DynamicCamera_getAngle(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DynamicCamera_getAngle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_getAngle.
 */
template<class T> Callback_DynamicCamera_getAnglePtr
newCallback_DynamicCamera_getAngle(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DynamicCamera_getAngle<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::DynamicCamera::begin_getAngle.
 * Create a wrapper instance by calling ::Domotics::newCallback_DynamicCamera_getAngle.
 */
template<class T, typename CT>
class Callback_DynamicCamera_getAngle : public Callback_DynamicCamera_getAngle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DynamicCamera_getAngle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DynamicCameraPrx proxy = DynamicCameraPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getAngle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_getAngle.
 */
template<class T, typename CT> Callback_DynamicCamera_getAnglePtr
newCallback_DynamicCamera_getAngle(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DynamicCamera_getAngle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_getAngle.
 */
template<class T, typename CT> Callback_DynamicCamera_getAnglePtr
newCallback_DynamicCamera_getAngle(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DynamicCamera_getAngle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::DynamicCamera::begin_setAngle.
 * Create a wrapper instance by calling ::Domotics::newCallback_DynamicCamera_setAngle.
 */
template<class T>
class CallbackNC_DynamicCamera_setAngle : public Callback_DynamicCamera_setAngle_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_DynamicCamera_setAngle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_setAngle.
 */
template<class T> Callback_DynamicCamera_setAnglePtr
newCallback_DynamicCamera_setAngle(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DynamicCamera_setAngle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_setAngle.
 */
template<class T> Callback_DynamicCamera_setAnglePtr
newCallback_DynamicCamera_setAngle(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DynamicCamera_setAngle<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_setAngle.
 */
template<class T> Callback_DynamicCamera_setAnglePtr
newCallback_DynamicCamera_setAngle(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DynamicCamera_setAngle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_setAngle.
 */
template<class T> Callback_DynamicCamera_setAnglePtr
newCallback_DynamicCamera_setAngle(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DynamicCamera_setAngle<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::DynamicCamera::begin_setAngle.
 * Create a wrapper instance by calling ::Domotics::newCallback_DynamicCamera_setAngle.
 */
template<class T, typename CT>
class Callback_DynamicCamera_setAngle : public Callback_DynamicCamera_setAngle_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_DynamicCamera_setAngle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_setAngle.
 */
template<class T, typename CT> Callback_DynamicCamera_setAnglePtr
newCallback_DynamicCamera_setAngle(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DynamicCamera_setAngle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_setAngle.
 */
template<class T, typename CT> Callback_DynamicCamera_setAnglePtr
newCallback_DynamicCamera_setAngle(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DynamicCamera_setAngle<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_setAngle.
 */
template<class T, typename CT> Callback_DynamicCamera_setAnglePtr
newCallback_DynamicCamera_setAngle(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DynamicCamera_setAngle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::DynamicCamera::begin_setAngle.
 */
template<class T, typename CT> Callback_DynamicCamera_setAnglePtr
newCallback_DynamicCamera_setAngle(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DynamicCamera_setAngle<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::Lamp::begin_getBrightness.
 * Create a wrapper instance by calling ::Domotics::newCallback_Lamp_getBrightness.
 */
template<class T>
class CallbackNC_Lamp_getBrightness : public Callback_Lamp_getBrightness_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Lamp_getBrightness(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LampPrx proxy = LampPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getBrightness(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_getBrightness.
 */
template<class T> Callback_Lamp_getBrightnessPtr
newCallback_Lamp_getBrightness(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Lamp_getBrightness<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_getBrightness.
 */
template<class T> Callback_Lamp_getBrightnessPtr
newCallback_Lamp_getBrightness(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Lamp_getBrightness<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::Lamp::begin_getBrightness.
 * Create a wrapper instance by calling ::Domotics::newCallback_Lamp_getBrightness.
 */
template<class T, typename CT>
class Callback_Lamp_getBrightness : public Callback_Lamp_getBrightness_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Lamp_getBrightness(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LampPrx proxy = LampPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getBrightness(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_getBrightness.
 */
template<class T, typename CT> Callback_Lamp_getBrightnessPtr
newCallback_Lamp_getBrightness(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Lamp_getBrightness<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_getBrightness.
 */
template<class T, typename CT> Callback_Lamp_getBrightnessPtr
newCallback_Lamp_getBrightness(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Lamp_getBrightness<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::Lamp::begin_setBrightness.
 * Create a wrapper instance by calling ::Domotics::newCallback_Lamp_setBrightness.
 */
template<class T>
class CallbackNC_Lamp_setBrightness : public Callback_Lamp_setBrightness_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Lamp_setBrightness(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_setBrightness.
 */
template<class T> Callback_Lamp_setBrightnessPtr
newCallback_Lamp_setBrightness(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Lamp_setBrightness<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_setBrightness.
 */
template<class T> Callback_Lamp_setBrightnessPtr
newCallback_Lamp_setBrightness(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Lamp_setBrightness<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_setBrightness.
 */
template<class T> Callback_Lamp_setBrightnessPtr
newCallback_Lamp_setBrightness(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Lamp_setBrightness<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_setBrightness.
 */
template<class T> Callback_Lamp_setBrightnessPtr
newCallback_Lamp_setBrightness(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Lamp_setBrightness<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::Lamp::begin_setBrightness.
 * Create a wrapper instance by calling ::Domotics::newCallback_Lamp_setBrightness.
 */
template<class T, typename CT>
class Callback_Lamp_setBrightness : public Callback_Lamp_setBrightness_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Lamp_setBrightness(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_setBrightness.
 */
template<class T, typename CT> Callback_Lamp_setBrightnessPtr
newCallback_Lamp_setBrightness(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Lamp_setBrightness<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_setBrightness.
 */
template<class T, typename CT> Callback_Lamp_setBrightnessPtr
newCallback_Lamp_setBrightness(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Lamp_setBrightness<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_setBrightness.
 */
template<class T, typename CT> Callback_Lamp_setBrightnessPtr
newCallback_Lamp_setBrightness(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Lamp_setBrightness<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::Lamp::begin_setBrightness.
 */
template<class T, typename CT> Callback_Lamp_setBrightnessPtr
newCallback_Lamp_setBrightness(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Lamp_setBrightness<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::RGBLamp::begin_getColor.
 * Create a wrapper instance by calling ::Domotics::newCallback_RGBLamp_getColor.
 */
template<class T>
class CallbackNC_RGBLamp_getColor : public Callback_RGBLamp_getColor_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const colorRGB&);

    CallbackNC_RGBLamp_getColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RGBLampPrx proxy = RGBLampPrx::uncheckedCast(result->getProxy());
        colorRGB ret;
        try
        {
            ret = proxy->end_getColor(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_getColor.
 */
template<class T> Callback_RGBLamp_getColorPtr
newCallback_RGBLamp_getColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const colorRGB&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RGBLamp_getColor<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_getColor.
 */
template<class T> Callback_RGBLamp_getColorPtr
newCallback_RGBLamp_getColor(T* instance, void (T::*cb)(const colorRGB&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RGBLamp_getColor<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::RGBLamp::begin_getColor.
 * Create a wrapper instance by calling ::Domotics::newCallback_RGBLamp_getColor.
 */
template<class T, typename CT>
class Callback_RGBLamp_getColor : public Callback_RGBLamp_getColor_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const colorRGB&, const CT&);

    Callback_RGBLamp_getColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RGBLampPrx proxy = RGBLampPrx::uncheckedCast(result->getProxy());
        colorRGB ret;
        try
        {
            ret = proxy->end_getColor(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_getColor.
 */
template<class T, typename CT> Callback_RGBLamp_getColorPtr
newCallback_RGBLamp_getColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const colorRGB&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RGBLamp_getColor<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_getColor.
 */
template<class T, typename CT> Callback_RGBLamp_getColorPtr
newCallback_RGBLamp_getColor(T* instance, void (T::*cb)(const colorRGB&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RGBLamp_getColor<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Domotics::RGBLamp::begin_setColor.
 * Create a wrapper instance by calling ::Domotics::newCallback_RGBLamp_setColor.
 */
template<class T>
class CallbackNC_RGBLamp_setColor : public Callback_RGBLamp_setColor_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RGBLamp_setColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_setColor.
 */
template<class T> Callback_RGBLamp_setColorPtr
newCallback_RGBLamp_setColor(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RGBLamp_setColor<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_setColor.
 */
template<class T> Callback_RGBLamp_setColorPtr
newCallback_RGBLamp_setColor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RGBLamp_setColor<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_setColor.
 */
template<class T> Callback_RGBLamp_setColorPtr
newCallback_RGBLamp_setColor(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RGBLamp_setColor<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_setColor.
 */
template<class T> Callback_RGBLamp_setColorPtr
newCallback_RGBLamp_setColor(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RGBLamp_setColor<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Domotics::RGBLamp::begin_setColor.
 * Create a wrapper instance by calling ::Domotics::newCallback_RGBLamp_setColor.
 */
template<class T, typename CT>
class Callback_RGBLamp_setColor : public Callback_RGBLamp_setColor_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RGBLamp_setColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_setColor.
 */
template<class T, typename CT> Callback_RGBLamp_setColorPtr
newCallback_RGBLamp_setColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RGBLamp_setColor<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_setColor.
 */
template<class T, typename CT> Callback_RGBLamp_setColorPtr
newCallback_RGBLamp_setColor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RGBLamp_setColor<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_setColor.
 */
template<class T, typename CT> Callback_RGBLamp_setColorPtr
newCallback_RGBLamp_setColor(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RGBLamp_setColor<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Domotics::RGBLamp::begin_setColor.
 */
template<class T, typename CT> Callback_RGBLamp_setColorPtr
newCallback_RGBLamp_setColor(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RGBLamp_setColor<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
